/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export function getNode(root: Node, gindex: string): Node
export function setNode(root: Node, gindex: string, value: Node): Node
export function setNodeWithFn(root: Node, gindex: string, getNewNode: (arg0: Node) => Node): Node
export function getNodeAtDepth(root: Node, depth: number, index: number): Node
/**
 * Fast read-only iteration
 * In-order traversal of nodes at `depth`
 * starting from the `start_index`-indexed node
 * iterating through `count` nodes
 *
 * **Strategy**
 * 1. Navigate down to parent depth storing a stack of parents
 * 2. At target level push current node
 * 3. Go up to the first level that navigated left
 * 4. Repeat (1) for next index
 */
export function getNodesAtDepth(root: Node, depth: number, startIndex: number, count: number): Array<Node>
/**
 * Set multiple nodes in batch, editing and traversing nodes strictly once.
 * - gindexes MUST be sorted in ascending order beforehand.
 * - All gindexes must be at the exact same depth.
 * - Depth must be > 0, if 0 just replace the root node.
 *
 * Strategy: for each gindex in `gindexes` navigate to the depth of its parent,
 * and create a new parent. Then calculate the closest common depth with the next
 * gindex and navigate upwards creating or caching nodes as necessary. Loop and repeat.
 */
export function setNodesAtDepth(root: Node, depth: number, indices: Array<number>, nodes: Array<Node>): Node
/**
 * Return the `Node` at a specified height from the merkle tree made of "zero data"
 * ```
 *           ...
 *          /
 *         x           <- height 2
 *      /     \
 *     x       x       <- height 1
 *   /  \      /  \
 * 0x0  0x0  0x0  0x0  <- height 0
 * ```
 */
export function zeroNode(height: number): Node
export function subtreeFillToDepth(bottom: Node, depth: number): Node
export function subtreeFillToLength(bottom: Node, depth: number, length: number): Node
export function subtreeFillToContents(nodes: Array<Node>, depth: number): Node
export type JsNode = Node
export class Node {
  get h0(): number
  get h1(): number
  get h2(): number
  get h3(): number
  get h4(): number
  get h5(): number
  get h6(): number
  get h7(): number
  set h0(value: number)
  set h1(value: number)
  set h2(value: number)
  set h3(value: number)
  set h4(value: number)
  set h5(value: number)
  set h6(value: number)
  set h7(value: number)
  get left(): Node
  get right(): Node
  get root(): Uint8Array
  get rootHashObject(): this
  isLeaf(): boolean
  constructor()
  static newLeafNode(h0: number, h1: number, h2: number, h3: number, h4: number, h5: number, h6: number, h7: number): JsNode
  static fromRoot(bytes: Uint8Array): JsNode
  static fromZero(): JsNode
  static fromUint32(value: number): JsNode
  static newBranchNode(left: Node, right: Node): JsNode
}
